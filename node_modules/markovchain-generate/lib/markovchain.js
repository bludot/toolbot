// Generated by CoffeeScript 1.9.3
(function() {
  var MarkovChain, path;

  path = require('path');

  MarkovChain = (function() {
    function MarkovChain(options) {
      if (options == null) {
        options = {};
      }
      this.sentence_beginning = this._beginning_key = options['beginningToken'] || '';
      this.BEGINNING_MARKER = "<BEGSTR>";
      this.ENDING_MARKER = "<ENDSTR>";
      this.__DEBUG = options['debug'] || false;
      this.db = options['db'] || {};
    }

    MarkovChain.prototype.print = function(s) {
      if (this.__DEBUG) {
        return console.log(s);
      }
    };

    MarkovChain.prototype.generateChain = function(textSample, sentenceSep) {
      var c, denominator, followProbabilities, followerCounts, followerTerm, i, j, k, l, len, len1, len2, line, nextTerms, ngrams, pair, probabilities, sequenceCounts, t, term, words;
      if (sentenceSep == null) {
        sentenceSep = /[.!?\n]/;
      }
      textSample = textSample.split(sentenceSep);
      sequenceCounts = {};
      probabilities = {};
      for (j = 0, len = textSample.length; j < len; j++) {
        line = textSample[j];
        if (line.trim().length < 1) {
          continue;
        }
        words = (this.BEGINNING_MARKER + " " + (line.trim()) + " " + this.ENDING_MARKER).split(" ");
        ngrams = (function() {
          var k, ref, results;
          results = [];
          for (i = k = 0, ref = words.length - 1; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            results.push([words[i], words[i + 1]]);
          }
          return results;
        })();
        for (k = 0, len1 = ngrams.length; k < len1; k++) {
          pair = ngrams[k];
          if (sequenceCounts[pair[0]] == null) {
            sequenceCounts[pair[0]] = {};
          }
          if (sequenceCounts[pair[0]][pair[1]] == null) {
            sequenceCounts[pair[0]][pair[1]] = 1;
          } else {
            sequenceCounts[pair[0]][pair[1]]++;
          }
        }
        for (term in sequenceCounts) {
          followerCounts = sequenceCounts[term];
          nextTerms = (function() {
            var results;
            results = [];
            for (t in followerCounts) {
              c = followerCounts[t];
              if (t !== this.BEGINNING_MARKER) {
                results.push(t);
              }
            }
            return results;
          }).call(this);
          denominator = 0;
          for (t in followerCounts) {
            c = followerCounts[t];
            if (t !== this.BEGINNING_MARKER) {
              denominator += c;
            }
          }
          followProbabilities = {};
          for (l = 0, len2 = nextTerms.length; l < len2; l++) {
            followerTerm = nextTerms[l];
            followProbabilities[followerTerm] = followerCounts[followerTerm] / denominator;
          }
          if (term === this.BEGINNING_MARKER) {
            followProbabilities[this.BEGINNING_MARKER] = 0.0;
          }
          probabilities[term] = followProbabilities;
        }
      }
      this.db = probabilities;
      return this.db;
    };

    MarkovChain.prototype.dump = function() {
      return JSON.stringify(this.db);
    };

    MarkovChain.prototype.load = function(dbJson) {
      return this.db = JSON.parse(dbJson);
    };

    MarkovChain.prototype.__getNextWord = function(lastwords) {
      var candidate, lastTerm, maxprob, maxprobword, probmap, sample;
      lastTerm = lastwords.slice(-1);
      probmap = this.db[lastTerm];
      sample = Math.random();
      maxprob = 0.0;
      maxprobword = "";
      for (candidate in probmap) {
        if (probmap[candidate] > maxprob) {
          this.print(probmap[candidate] + " > " + maxprob);
          maxprob = probmap[candidate];
          maxprobword = candidate;
        }
        if (sample > probmap[candidate]) {
          sample -= probmap[candidate];
        } else {
          return candidate;
        }
      }
      return maxprobword;
    };

    MarkovChain.prototype.__generateFromState = function(words) {
      var nextword, sentence;
      nextword = this.__getNextWord(words);
      sentence = words != null ? words : [];
      while (nextword !== this.ENDING_MARKER) {
        sentence.push(nextword);
        nextword = this.__getNextWord(sentence);
      }
      return sentence.join(" ").replace(this.BEGINNING_MARKER, this._beginning_key).trim();
    };

    MarkovChain.prototype.generateString = function() {
      return this.__generateFromState([this.BEGINNING_MARKER]);
    };

    return MarkovChain;

  })();

  module.exports = MarkovChain;

}).call(this);
